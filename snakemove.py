import numpy as np
import logging

from path import Path
from funcs import plot_paths, overlay_paths

import matplotlib.pyplot as plt

from moves import cut_LR_to_M, cut_extremal_phasepoints, propagate

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

"""
Old functions that allowed a snake to use its memory of prior MCMC paths.
Detailed balance, however, forces a memoryless existence onto any snake 
that desires to live. No worry buddy, I will remember you for you.
"""


def smart_repptis_swap(ensembles, idx):
    """ If a swap could be possible between ensembles [i^+-] and [(i+1)^+-],
    then the swap WILL be done. 
    """
    ens1 = ensembles[idx]
    ens2 = ensembles[idx+1]
    # logger.info("Pathtypes: {} and {}".format(ens1.paths[0].ptype,
    #                                          ens2.paths[0].ptype))
    # check both 
    # for [i^+-] -> [(i+1)^+-] we try FW first, then BW
    # for [(i+1)^+-] -> [i^+-] we try BW first, then FW
    # waggle FW from [i^+-]
    reverse1, ens1_fw = snake_waggle(ensembles, ens1, propdir="forwards")
    if ens1_fw.id == ens2.id:
        tr1 = False
    else: # waggle BW from [i^+-]
        reverse1, ens1_bw = snake_waggle(ensembles, ens1, propdir="backwards")
        if ens1_bw.id == ens2.id:
            tr1 = True
        else:
            return "SWD", ens1.paths[0], ens2.paths[0]
    # waggle BW from [(i+1)^+-]
    reverse2, ens2_bw = snake_waggle(ensembles, ens2, propdir="backwards")
    if ens2_bw.id == ens1.id:
        tr2 = False
    else: # waggle FW from [(i+1)^+-]
        reverse2, ens2_fw = snake_waggle(ensembles, ens2, propdir="forwards")
        if ens2_fw.id == ens1.id:
            tr2 = True
        else:
            return "SWD", ens1.paths[0], ens2.paths[0]
    # We now have the propagation directions for both paths, so we just 
    # propagate them (they will be acceptable).
    # logger.info("Propagation time directions: {} and {}".format(
    #    reverse1, reverse2))
    status1to2, new_path_1to2 = snake_propagator(ens1, ens2, reverse1,
                                                 tr=tr1, forcing=False)
    status2to1, new_path_2to1 = snake_propagator(ens2, ens1, reverse2,
                                                 tr=tr2, forcing=False)
    if status1to2 == "ACC" and status2to1 == "ACC":
        return "ACC", new_path_2to1, new_path_1to2
    else:
        return "BAD", new_path_2to1, new_path_1to2


def snake_move(ensembles, Lmax=10, simcycle=0, tail_id=None, can_eat_tail=True):
    """ Performs the snake move. 
    For now, detailed balance is broken. 
    I will have to either: 
    A) Keep the same format, but:
        a) use two parallel pathensembles for each ensemble
        b) use weights for the paths
    B) Only allow for tail-eating snakes. Weights are attributed to all paths, 
    where w = 1 / N_possible_circular_snakes. This will be fun to implement!


    The snake move uses paths that are older than the last_path. 

    The algorithm is as follows:

    1. Choose a random ensemble where the snake spawns. This is the tail-
    ensemble of the snake E_tail. The length of the snake is now 1 (L=1).

    2. Propagate the last accepted path of E_tail forwards or backwards 
    into a neighbouring ensemble. This ensemble is the head-ensemble of 
    the snake E_head. The direction of propagation is chosen randomly. L=2.

    3. While L < Lmax and not eats_own_tail:
        
        3.1. Propagate the path at the **lowest available level** of
        E_head forwards or backwards into a neighbouring ensemble. The 
        lowest available level denots the lowest E_head.paths index that
        has not yet been used to propagate the snake.
        This ensemble is the new head-ensemble of the snake E_head. 
        The direction of propagation is chosen randomly. L += 1.

        3.2. If E_head == E_tail, eats_own_tail = True. Else, continue.

    4. If not eats_own_tail:
            
        4.1. For body-ensembles (i.e. all the ensembles the snake has 
        visited except for the tail- and head-ensembles):
        Call N_i the number of times the snake visited a body ensemble E_i. 
        The N_i-th path generated by the snake move becomes the last
        accepted path of E_i. The (N_i-1)-th path generated by the snake
        move becomes the second-last accepted path, etc. 
        The last-accepted path of the old superstate is thus lost. 
        NET GAIN of paths: 0

        4.2. For the tail-ensemble: Remove the last accepted path of E_tail,
        and cascade the older paths upwards: the second-last accepted path
        becomes the last accepted path, the third-last accepted path becomes
        the second-last accepted path, etc.
        NET GAIN of paths: -1

        4.3. For the head-ensemble: We do the same as for the body-ensembles
        where we treat the last-accepted path of the old superstate as 
        firstly generated path of E_head. 
        NET GAIN of paths: +1

    5. If eats_own_tail:

        5.1. Body-ensembles: Same as for non-eats_own_tail.
        Net GAIN of paths: 0

        5.2. Tail ensemble == head ensemble, and this ensemble is (by
        definition) visited twice. The newly generated path in E_headtail
        becomes the new last accepted path, and the previous last-accepted
        path becomes the new second-last-accepted path. 
        NET GAIN of paths: 0

    """
    # Things we will have to track:
    visits = np.zeros(len(ensembles), dtype=int)
    L = 0
    eats_own_tail = False
    snake_skeleton = []
    # Elements of snake_paths are lists of tuples (status, trial) of the 
    # paths generated by the snake move in the corresponding ensemble.
    snake_paths = [[] for _ in range(len(ensembles))]

    # Step 1: Choose a random ensemble where the snake spawns. This is the
    # tail-ensemble of the snake E_tail. The length of the snake is now 1.
    exclude_from_spawn = False
    if tail_id is not None:
        E_tail = ensembles[tail_id]
    elif exclude_from_spawn:
        # We cannot let the snake spawn in primed ensembles.
        spawnable_ids = []
        for ens in ensembles: 
            if ens.ens_type not in ["PPTIS_Nplusmin_primed",
                                    "PPTIS_0plusmin_primed"]:
                spawnable_ids.append(ens.id)
        spawnid = np.random.choice(spawnable_ids)
        E_tail = ensembles[spawnid]
    else:
        E_tail = np.random.choice(ensembles)
    L += 1
    visits[E_tail.id] += 1
    snake_skeleton.append(E_tail.id)
    logger.info("Snake spawned in ensemble {} ({})".format(E_tail.name,
                                                           E_tail.id))

    # Step 2: Propagate the last accepted path of E_tail forwards or
    # backwards into a neighbouring ensemble.
    reverse, E_head = snake_waggle(ensembles, E_tail)
    status, trial = snake_propagator(ensembles, E_tail, E_head, reverse)
    # if the logger is set to debug, we plot the trial path, and the path
    # from which it was built.
    if logger.getEffectiveLevel() == logging.DEBUG:
        import matplotlib.pyplot as plt
        fig, ax = plt.subplots()
        overlapids = overlay_paths(E_tail.paths[0], [trial])
        startids = [0,overlapids[0][1]] if reverse == 1\
            else [overlapids[0][2],0]
        ppaths = [E_tail.paths[0], trial]
        plot_paths(ppaths, ax=ax, start_ids=startids)
        ax.set_title("Prop {}: from {} (level {}) to {}".format(
            L, E_tail.name, 0, E_head.name))
        fig.show()

    # Update snake information
    snake_paths[E_head.id].append((status, trial))
    visits[E_head.id] += 1
    L += 1
    snake_skeleton.append(E_head.id)
    logger.info("Wiggle status: {}. L = {}".format(status, L))

    # Step 3: While L < Lmax and not eats_own_tail:
    while L < Lmax and not eats_own_tail:
        level = visits[E_head.id] - 1
        E_head_old = E_head
        reverse, E_head = snake_waggle(ensembles, E_head, level=level)
        if E_head.id == E_tail.id and can_eat_tail:
            eats_own_tail = True
            logger.info("Snake will eat its own tail!")
        status, trial = snake_propagator(ensembles, E_head_old, E_head,
                                         reverse, level=level)
        # if the logger is set to debug, we plot the trial path, and the path
        # from which it was built.
        if logger.getEffectiveLevel() == logging.DEBUG:
            fig, ax = plt.subplots()
            overlapids = overlay_paths(E_head_old.paths[level], [trial])
            startids = [0,overlapids[0][1]] if reverse == 1\
                else [overlapids[0][2],0]
            ppaths = [E_head_old.paths[level], trial]
            plot_paths(ppaths, ax=ax, start_ids=startids)
            ax.set_title("Prop {}: from {} (level {}) to {}".format(
                L, E_head_old.name, level, E_head.name))
            fig.show()
                
        # Update snake information
        snake_paths[E_head.id].append((status, trial))
        visits[E_head.id] += 1
        L += 1
        snake_skeleton.append(E_head.id)
        logger.info("Wiggle status: {}. L = {}".format(status, L))

    logger.info("Snake move finished with L = {} (L_max = {}).".format(L, Lmax))
    logger.info("Doing bookkeeping")
    # step 4: Bookkeeping
    # 4.1.: Tail-ensemble: Remove the last accepted path of E_tail, 
    # which is the first path in E_tail.paths, and cascade upwards
    # TODO: do I also have to update the data for this pop? Right now, I'm not
    # discriminating whether we have tail-eating or not, and then it seems
    # like I have to update the data (to be similar to non-tail-eating).
    # It's easy, we just bookkeep the last N accepted paths of each ensemble,
    # This is, however, a completely different approach of updating data, and 
    # you'll have to update the other moves as well... Well, not necessarily,
    # after every move you can just add a 'update_N_paths function", which
    # saves the data of the last N paths of each ensemble to a second 
    # pathensemble2.txt file :) of course, we can also just update the weights
    # of the existing paths, but I think this clashes with the mindset of also
    # putting rejected paths in the pathensemble.txt file. I think in post
    # processing, we can update the path weights by amount of occurrence in the 
    # staggered pathensembe2.txt file, afther which we create a new pathensemble
    # file which only contains ACC paths with integer weights >=1. Aighty aight.
    
    # First busieth deinselbs met de one-only sliz.
    # Here, the paths will end up in the correct hierarchy, and then we can 
    # create the staggered pathensemble version afterwards. We just pop and 
    # add the paths in the way they were itended. Then we update paths for 
    # the ensembles that were visited. Easy as that.
    logger.info("Snake move done!")
    logger.info("Snake skeleton: {}".format(snake_skeleton))
    logger.info("Snake paths: {}".format(snake_paths))
    logger.info("Snake visits: {}".format(visits))
    logger.info("Ensemble ids: {}".format([ens.id for ens in ensembles]))
    logger.info("Snake eats own tail: {}".format(eats_own_tail))
    logger.info("Snake length: {}".format(L))
    logger.info("Snake head: {}".format(E_head.name))
    logger.info("Snake tail: {}".format(E_tail.name))
    # 1) E_tail pops its latest path: net loss of one path here
    E_tail.paths.pop(0)
    # 2) E_head gets a placeholder at position 0: net gain of one path here
    E_head.paths.insert(0, None)
    # 3) Body-ensembles:
    for i, ens in enumerate(ensembles):
        if i == E_tail.id:
            # Tail ensemble can max have one newly generated path in the case
            # of tail-eating. If this is the case, we can add the newly 
            # generated path. If not, continue
            if eats_own_tail:
                E_tail.paths[0] = snake_paths[i][0][1]
        else:
            for j in range(visits[i]):
                ens.paths[visits[i]-j-1] = snake_paths[i][j][1]
            #ens.update_data(*snake_paths[i][j], "SB", simcycle)
    # 4) Updating data. 
    # TODO: Do I only update the data of the ensembles that the snake has 
    # visited? Or do I add null moves in the unvisited ensembles? I think the 
    # latter is the correct one, as we don't have a 'systematic' way of 
    # performing the snake move in all ensembles (which was the chase for the 
    # shooting and swapping 'array' moves...) 
    # New flags:
    # 1) SB: snake body
    # 2) SH: snake head (no tail-eating)
    # 3) ST: snake tail (no tail-eating)
    # 4) SE: snake eats own tail
    # 5) S0: not visited, null move
    for i, ens in enumerate(ensembles):
        if i == E_tail.id:
            if eats_own_tail:
                flag = "SE"
            else:
                flag = "ST"
        elif i == E_head.id:
            flag = "SH"
        elif i in snake_skeleton:
            flag = "SB"
        else:
            flag = "S0"
        ens.update_data("ACC", ens.paths[0], flag, simcycle, update_paths=False)
        if i in snake_skeleton and ens.save_pe2:
            ens.write_to_pe2(gen=flag)  # 5) Updating pathensemble2.txt files
    # 
    # # for the ensembles visited by the snake, we update pathensemble2.txt
    # # with the newly generated paths. For the other ensembles, we do nothing
    # for i, ens in enumerate(ensembles):
    #     if i in snake_skeleton and ens.save_pe2:
    #         ens.write_to_pe2(gen='SN')
    # we return snake information, for debugging purposes
    return snake_skeleton, snake_paths, visits

def snake_waggle(ensembles, E_head, level=0, propdir=None, path=None,
                 multilevel=False):
    """Snake wiggles from E_head to a neighbouring ensemble, which becomes
    the new E_head. To propagate, we will need a propagation direction, the 
    new E_head. 

    Parameters
    ----------
    ensembles : list of :py:class:`Ensemble` objects
        List of all ensembles in the system.
    E_head : :py:class:`Ensemble` object
        The ensemble from which the snake will propagate.
    level : int
        Level at which the snake propagates. Level 0 is the last-accepted path,
        level 1 is the second-last accepted path, etc.
    propdir : str
        Direction of propagation, either "forwards" or "backwards". If None,
        the direction is chosen randomly.
    path : :py:class:`Path` object
        Path that the snake will propagate.
        If None, the level-th path of E_head is propagated.

    Returns
    -------
    reverse : int
        Reverse factor, either 1 or -1.
    new_E_head : :py:class:`Ensemble` object
        The new ensemble that becomes the snake head.

    """
    if propdir is None:
        propdir = np.random.choice(["forwards", "backwards"])
    else:
        assert propdir in ["forwards", "backwards"], f"invalidpropdir:{propdir}"
    reverse = -1 if propdir == "backwards" else 1
    LR_mappu = 0 if propdir == "backwards" else -1
    if path is None:
        ptype = E_head.get_ptype(E_head.paths[level])
    else:
        ptype = E_head.get_ptype(path)
    L_or_R = ptype[LR_mappu]
    assert L_or_R in ["L", "R"], "L_or_R is not L or R"

    if multilevel:  # TODO: this only works when MD steps are only performed
        # in shooting moves, as I hard-codedly pick the 0-th level ensemble
        # as I assume this to be for generating (and not sampling) purposes
        # only.
        new_E_head_id = E_head.id[0] + 1 if L_or_R == "R" else E_head.id[0] - 1
        new_E_head = ensembles[0][new_E_head_id]
    else:
        new_E_head_id = E_head.id + 1 if L_or_R == "R" else E_head.id - 1
        new_E_head = ensembles[new_E_head_id]
    msg=f"Snake wiggles {propdir} on an {ptype} path at level {level} from "
    msg+=f"{E_head.name} ({E_head.id}) to {new_E_head.name} ({new_E_head.id})"
    logger.debug(msg)
    return reverse, new_E_head

def snake_propagator(E_head_old, E_head, reverse, level=0, forcing=True,
                     tr=False, path=None):
    """ After the snake arrives in an ensemble, we propagate the lowest-
    available path in that ensemble forwards or backwards.
    
    Parameters
    ----------
    ensembles : list of :py:class:`Ensemble` objects
        List of all the ensembles in the simulation
    E_head_old : :py:class:`Ensemble` object
        Ensemble where the snake was before it propagated to E_head
    E_head : :py:class:`Ensemble` object
        Ensemble where the snake currently is
    reverse : float
        Whether to propagate forwards (1.) or backwards (-1.)
    tr : bool
        Whether or not the trial path should be time-reversed after propagation.

    Returns
    -------
    status : str
        Status of the propagation. Either "ACC" or one of the REJ flags.
    trial : :py:class:`Path` object
        The trial path that was generated by the snake move.

    """
    if not forcing:
        if E_head_old.ens_type in ["state_A", "state_B"] or\
                E_head.ens_type in ["state_A", "state_B"]:
            logger.info("Propagate without overlap")
            return snake_propagate_no_overlap(E_head_old, E_head, reverse,
                                              level=level, tr=tr, path=path)
        elif E_head_old.ens_type == "body_PPTIS" and\
                E_head.ens_type in ["PPTIS_0plusmin_primed",
                                    "PPTIS_Nplusmin_primed"]:
            logger.info("Propagate with full overlap")
            return snake_propagate_full_overlap(E_head_old, E_head, reverse,
                                                level=level, tr=tr, path=path)
        else:
            logger.info("Propagate with partial overlap")
            return snake_propagate(E_head_old, E_head, reverse, level=level,
                                   tr=tr, path=path)
    # we are forcing
    # --------------
    # A) whether we end up or start from state A or B, we have no overlap.
    if E_head_old.ens_type in ["state_A", "state_B"] or\
            E_head.ens_type in ["state_A", "state_B"]:
        logger.info("Propagate without overlap")
        # This will propagate into 
        return snake_propagate_no_overlap(E_head_old, E_head, reverse,
                                          level=level, tr=True)
    # B) No state A or B is involved. So if a primed ensemble is involved now, 
    #    it must be with a body ensemble. 
    # If we end up in a primed ensemble, there must have been full overlap.
    elif E_head.isprimed:
        logger.info("Propagate with full overlap")
        return snake_propagate_full_overlap(E_head_old, E_head, reverse,
                                            level=level, tr=True)
    # If we start from a primed ensemble, we can just propagate the path.
    elif E_head_old.isprimed:
        logger.info("Propagate with partial overlap")
        return snake_propagate(E_head_old, E_head, reverse,
                               level=level, tr=True)
    # C) No primed or state A or B involved. We can just propagate the path.
    elif E_head_old.ens_type in ["iL", "iR"]:
        logger.info("Propagate with partial overlap")
        return snake_propagate(E_head_old, E_head, reverse,
                               level=level, tr=True)
    else:
        raise ValueError("Unknown ensemble types involved in snake move")

def snake_propagate(E_head_old, E_head, reverse,
                    level=0, tr=False, path=None):
    """ After the snake arrives in an ensemble, we propagate the lowest-
    available path in that ensemble forwards or backwards.
    
    Parameters
    ----------
    E_head : :py:class:`Ensemble` object
        Ensemble where the snake currently is
    reverse : float
        Whether to propagate forwards (1.) or backwards (-1.)
    level : int
        Level at which the snake propagates. Level 0 is the last-accepted path,
        level 1 is the second-last accepted path, etc.
    tr : bool
        Whether or not the trial path should be time-reversed after propagation.

    Returns
    -------
    status : str
        Status of the propagation. Either "ACC" or one of the REJ flags.
    trial : :py:class:`Path` object
        The trial path that was generated by the snake move.

    """
    ph_overlap, op_overlap, sh = \
        cut_LR_to_M(E_head_old, reverse, level=level, path=path)
    maxlen_prop = E_head.max_len - len(ph_overlap)
    status, trial_tuple = propagate(E_head, sh, reverse, maxlen_prop)
    if reverse == -1:
        trial = Path(trial_tuple[0] + ph_overlap, trial_tuple[1] + op_overlap,
                     trial_tuple[2])
    else:
        trial = Path(ph_overlap + trial_tuple[0], op_overlap + trial_tuple[1],
                     trial_tuple[2])
    if tr:
        logger.debug("Time-reversing the trial path") 
        trial.time_reverse()
    if not E_head.check_path(trial):
        logger.warning("Propagated path is not valid, ptype: {}".format(
            E_head.get_ptype(trial)))
        print("Propagated path is not valid")
        plot_paths([E_head_old.paths[level], trial])
    assert E_head.check_path(trial), "Propagated path is not valid"
    return status, trial


def snake_propagate_no_overlap(E_head_old, E_head, reverse, level=0, tr=False,
                               path=None):
    """The snake is in the [0^-'] ensemble, and it has been decided
    to propagate towards the new E_head == [0^+-'] ensemble. We don't have
    an overlap region in this case, and we perform half of the swap_zero move.
    
    Parameters
    ----------
    E_head_old : :py:class:`Ensemble` object
        Ensemble where the snake was before it propagated to E_head ([0^-'])
    E_head : :py:class:`Ensemble` object
        Ensemble where the snake currently is ([0^+-'])
    prop_dir : str
        Direction of propagation, either "forwards" or "backwards"
    neighb_side : str
        Side from which we cut the overlap phasepoints: not needed here.
    reverse : float
        Whether to propagate forwards (1.) or backwards (-1.)
    level : int
        Level at which the snake propagates. Level 0 is the last-accepted path,
        level 1 is the second-last accepted path, etc.
    tr : bool
        Whether or not the trial path should be time-reverse after propagation.

    """
    # Get the two phasepoints that will be copied
    ph_overlap, op_overlap, sh = cut_extremal_phasepoints(E_head_old, reverse,
                                                          level=level,
                                                          path=path)
    maxlen_prop = E_head.max_len - 2
    status, trial_tuple = propagate(E_head, sh, reverse, maxlen_prop)
    if reverse == -1:
        trial = Path(trial_tuple[0] + ph_overlap, trial_tuple[1] + op_overlap,
                     trial_tuple[2])
    else:
        trial = Path(ph_overlap + trial_tuple[0], op_overlap + trial_tuple[1],
                     trial_tuple[2])
    if tr:
        logger.debug("Time-reversing the trial path")
        trial.time_reverse()
    # make a figure of the trial path and the path from which it was built
    # if not E_head.check_path(trial):
    #     fig, ax = plt.subplots()
    #     overlapids = overlay_paths(E_head_old.paths[level], [trial])
    #     startids = [0,overlapids[0][1]] if reverse == 1\
    #         else [overlapids[0][2],0]
    #     ppaths = [E_head_old.paths[level], trial]
    #     plot_paths(ppaths, ax=ax, start_ids=startids)
    #     ax.set_title("Prop: from {} (level {}) to {}".format(E_head_old.name, level, E_head.name))
    #     fig.show()
    # if not E_head.check_path(trial):
    #     logger.warning("Propagated path is not valid, ptype: {}".format(
    #         E_head.get_ptype(trial)))
    #     print("Propagated path is not valid")
    #     plot_paths([E_head_old.paths[level], trial])
    assert E_head.check_path(trial), "Propagated path is not valid"
    return status, trial

def snake_propagate_full_overlap(E_head_old, E_head, reverse,
                                 level=0, tr=False, path=None):
    """Snake is propagated from ensemble E_head_old to E_head. The phasespace 
    of E_head is a subspace of the phasespace of E_head_old, and if we 
    entered this propagation mode, than the new path can just be cut out of 
    the old path. 
    
    Parameters
    ----------
    E_head_old : :py:class:`Ensemble` object
        Ensemble where the snake was before it propagated to E_head
    E_head : :py:class:`Ensemble` object
        Ensemble where the snake currently is
    level : int
        Level of the path to cut. Level 0 is the last-accepted path, level 1
        is the second-last accepted path, etc.

    """
    ph_overlap, op_overlap, sh = \
        cut_LR_to_M(E_head_old, reverse, level=level, path=path)
    # This cut-out path should already satisfy E_head pathensemble criteria
    trial = Path(ph_overlap, op_overlap, E_head.id)
    # Check whether the path meets the criteria
    # plot the path
    # fig, ax = plt.subplots()
    # ax.plot([op[0] for op in trial.orders])
    # ax.set_title("Snake propagation from {} to {}".format(
    #     E_head_old.name, E_head.name))
    # fig.show()
    if tr:
        logger.debug("Time-reversing the trial path")
        trial.time_reverse()
    if not E_head.check_path(trial):
        logger.warning("Propagated path is not valid, ptype: {}".format(
            E_head.get_ptype(trial)))
        print("Propagated path is not valid")
        plot_paths([E_head_old.paths[level], trial])
    assert E_head.check_path(trial), "Path does not meet criteria"
    return "ACC", trial

## OLDER ONES ## 
def snake_wiggle(ensembles, E_head, level=0):
    """Snake wiggles from E_head to a neighbouring ensemble, which becomes
    the new E_head. We get a propagation direction, the side from which we 
    cut the overlap path, and the reverse factor. 
    
    Parameters
    ----------
    ensembles : list of :py:class:`Ensemble` objects
        List of all the ensembles in the simulation
    E_head : :py:class:`Ensemble` object
        Ensemble where the snake currently is
    level : int
        Level at which the snake propagates. Level 0 is the last-accepted path, 
        level 1 is the second-last accepted path, etc.

    Returns
    -------
    prop_dir : str
        Direction of propagation, either "forwards" or "backwards"
    neighb_side : str
        Side from which we cut the overlap phasepoints. This is either "left"
        or "right". Left: we cut the overlap path from ensemble i to create a 
        path in ensemble i+1. Right: we cut the overlap path from ensemble i
        to create a path in ensemble i-1.
    reverse : float
        Whether to propagate forwards (1.) or backwards (-1.)
    E_head : :py:class:`Ensemble` object
        Ensemble where the snake is now
    
    """
    prop_dir = np.random.choice(["forwards", "backwards"])
    reverse = -1 if prop_dir == "backwards" else 1
    ptype = E_head.get_ptype(E_head.paths[level])
    prop_dict = {"loc" : {"forwards": -1,  # take first/last of ptype (e.g. LMR)
                          "backwards": 0},
                "side" : {"L": "right",  # from which side do we cut overlap?
                          "R": "left"},
                "neighb_idx" : {"right": -1,  # new path in id + or - 1
                                "left": 1}
                }
    neighb_loc = ptype[prop_dict["loc"][prop_dir]]
    neighb_side = prop_dict["side"][neighb_loc]
    E_head = ensembles[E_head.id + prop_dict["neighb_idx"][neighb_side]]
    return prop_dir, neighb_side, reverse, E_head


def forced_extension(ensembles, idx):
    """Perform a forced extension of a path in PPTIS ensemble idx. This extends
    the path forwards/backwards in time until the path satisfies the conditions 
    of the ensemble it is propagated into. To obey detailed balance, we will 
    have to pop the last path of ensemble idx, and insert the newly generated
    path into ensemble idx+-1 (depending on which direction the path is 
    propagated into). In essence, this is a snake move of length L=2.
    
    Parameters
    ----------
    ensembles : list of :py:class:`Ensemble` objects
        List of ensembles present in the simulation
    idx : int
        Index of the ensemble whose path is extended

    Returns
    -------
    status : str
        Status of the propagation.
    trial_tuple : tuple
        tuple of (phs, ops, ens.id) of the trial path
    """
    # At first, the move just starts as a normal repptis_swap move. Instead of 
    # checking whether the move is allowed, we just propagate the path in the 
    # chosen propagation direction. 
    reverse, E_head = snake_waggle(ensembles, ensembles[idx], level=0)
    status, trial = snake_propagator(ensembles[idx], E_head,
                                     reverse, level=0, forcing=False)
    
    # fig, ax = plt.subplots()
    # overlapids = overlay_paths(ensembles[idx].paths[0], [trial])
    # startids = [0,overlapids[0][1]] if reverse == 1\
    #     else [overlapids[0][2],0]
    # ppaths = [ensembles[idx].paths[0], trial]
    # ensembles[idx].intfs is a dictionary with keys 'L', 'M' and 'R', which
    # hold the values of the left, middle and right interface of the ensemble.
    # M can be None, so we can't pass that to plot_paths. But if it is not
    # None, we should pass it to plot_paths.
    # intfvalues = [ensembles[idx].intfs['L'], ensembles[idx].intfs['R'],
    #                 ensembles[idx].intfs['M'], E_head.intfs['L'],
    #                 E_head.intfs['R'], E_head.intfs['M']]
    # intfs = [intf for intf in intfvalues if (intf is not None)] 
    # intfs = [intf for intf in intfs if (intf < 1000 and intf > -1000)]
    # plot_paths(ppaths, ax=ax, start_ids=startids, intfs=intfs)
    # ax.set_title("Prop from {} to {}".format(
    #     ensembles[idx].name, E_head.name))
    # fig.show()  


    # Let's plot the level 0 and level 1 paths of both ensembles before and 
    # after this move has been finished. 
    # import matplotlib.pyplot as plt
    # fig, ax = plt.subplots()
    # l0paths = [ensembles[idx].paths[0], E_head.paths[0]]
    # l1paths = [ensembles[idx].paths[1], E_head.paths[1]]
    # l2paths = [ensembles[idx].paths[2], E_head.paths[2]]
    # plot_paths(l0paths, ax=ax, start_ids=[0,0], color="r")
    # plot_paths(l1paths, ax=ax, start_ids=[1000,1000], color="g")
    # plot_paths(l2paths, ax=ax, start_ids=[2000,2000], color="b")
    # ax.set_title("Before the forced extension...")
    # fig.show()
    # Let's do it again, but plot make two subplots, one for idx and one for head
    # fig, (ax1, ax2) = plt.subplots(1,2)
    # idxpaths = [ensembles[idx].paths[0], ensembles[idx].paths[1],
    #             ensembles[idx].paths[2]]
    # headpaths = [E_head.paths[0], E_head.paths[1], E_head.paths[2]]
    # plot_paths(idxpaths, ax=ax1, start_ids="staggered")
    # plot_paths(headpaths, ax=ax2, start_ids="staggered")
    # ax1.set_title("{}: Before the forced extension...".format(
    #     ensembles[idx].name))
    # ax2.set_title("{}: Before the forced extension...".format(
    #     E_head.name))
    # fig.show()
    # if True:
    #     import matplotlib.pyplot as plt
    #     fig, ax = plt.subplots()
    #     overlapids = overlay_paths(ensembles[idx].paths[0], [trial])
    #     startids = [0,overlapids[0][1]] if reverse == 1\
    #         else [overlapids[0][2],0]
    #     ppaths = [ensembles[idx].paths[0], trial]
    #     plot_paths(ppaths, ax=ax, start_ids=startids)
    #     ax.set_title("Prop: from {} (level {}) to {}".format(
    #         ensembles[idx].name, 0, E_head.name))
    #     fig.show()
    assert E_head.check_path(trial), "Path does not meet criteria..."

    return status, trial, E_head.id
